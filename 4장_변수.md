## Q1. 메모리 접근 단위는 왜 1byte 인가요?
벤치마킹 했을 시 가장 많이 사용 되는 데이터 타입은 알파벳을 저장할 수 있는 8bit 크기의 char형 입니다. 그렇기 때문에 1byte 단위로 메모리를 접근하는 것이 성능 측면에서 이득을 볼 수 있습니다.

## Q2. 자바스크립트의 변수 할당 과정을 메모리 구조와 같이 설명해주세요
아래 예제를 통해서 설명 드리겠습니다. 
```js
var score = 80;
```
자바스크립트 엔진은 크게 2가지 단계 변수를 선언하고 초기화하는 **평가단계**와 구문을  실행하는 **실행단계**을 가집니다. 

![](https://images.velog.io/images/whow1101/post/b3fb5a03-c551-4a51-bb5c-34ff86301b41/4-3.png)

위의 그림은 평가단계를 마친 후의 메모리 구조이며 해당 주소를 변수 score가 가르키며 undefined으로 값이 초기화되어 있는 모습입니다.

조금 더 자세히 이야기 드리면 평가단계에서 실행 컨텍스트가 생성되며 실행 컨텍스트는 undefined으로 초기화된 변수 score를 가지는 scope를 포함하게 됩니다.

![](https://images.velog.io/images/whow1101/post/7f15c9e1-b0b2-422a-936c-6749c2466604/4-4.png)

이후 실행 단계를 거쳐 메모리에 값 80이 저장되고 변수 score는 해당 주소를 기억하게 됩니다. 여기서 undefined이 저장되어있는 주소의 값이 변경되는 것이 아닌 새로운 메모리 공간을 확보하고 값을 저장합니다.

### Q2-1. 왜 undefined이 저장되어있는 메모리에에 값을 덮어쓰지않고 새로운 메모리를 할당해서 값을 저장하나요?
자바스크립트는 직접적인 메모리 접근을 허용하지 않기 때문입니다.

프로그래밍 언어는 메모리 관리 방식에 따라 unmanaged 언어와 managed 언어로 분류 할 수 있습니다. 자바스크립트는 managed 언어로 메모리 관리를 자바스크립트 엔진이 맡아서 관리합니다. 

자바스크립트가 managed 언어를 체택한 이유는 유저에게 편의성을 제공하기 위해서 입니다. 자바스크립트의 탄생 배경은 웹사이트를 동적으로 바꾸고 싶어서 만들어진 가벼운 언어입니다. 그렇기 때문에 개발자에게 편의성을 제공하는 것에 초점을 맞추어 개발이 되었습니다.

## Q3. 호이스팅에 대해서 설명해주세요
A호이스팅은 코드를 실행하기 전에 Interpreter가 변수, 함수 등의 선언을 스코프의 맨 위로 이동하는 것처럼 보이는 프로세스를 나타냅니다.

```js
console.log(score); // undefined
var score;
```
위 예제에서 undefined을 출력하는 것을 볼 수 있습니다. 변수 score가 선언되기 이전에도 값을 가지고 있습니다. 이처럼 **변수 선언이 코드의 맨 위로 이동한 것처럼 동작하는 자바스크립트 고유의 특징을 호이스팅 이라고 합니다.**

자바스크립트 엔진은 '소스코드의 평가'와 '소스코드의 실행'과정으로 나누어서 처리합니다. 소스코드의 평가과정에서는 실행 컨텍스트를 생성하고 변수, 함수 등의 선언문만 먼저 실행됩니다. 실행과정에서 console.log(score) 구문을 만나게 되고 undefined으로 초기화 되어있는 score 값을 출력하게 됩니다.

## Q4. Garbage Collection에 대해서 설명해주세요
Garbage Collection(GC)는 garbage라고 불리는 더 이상 참조되지 않는 메모리를 자동으로 반환하는 메모리 관리입니다.

GC는 개발자에게 메모리를 할당하고 반환하는 부담을 덜어주기는 했으나 garbage 탐색의 오버헤드로 인해서 성능 저하를 일으키는 단점이 있습니다. 

JavaScript 예제로 Garbage Collection의 동작원리를 보겠습니다.
```js
var x = {
  a: {
    b: 2
  }
};
// b를 참조하는 object a와 a를 참조하는 object x를 선언하였습니다.

var y = x;      // 변수 'y'는 x를 참조하게 됩니다.

x = 1;          // 이제 x는 값 1이 할당이 되었습니다. 하지만 여전히 변수 y가 처음 선언된 
                // x값을 참조하고 있어 GC는 동작하지 않습니다.

var z = y.a;    // 변수  'z'는 y.a를 참조하게 됩니다.

y = 'mozilla';  // 이제 처음 선언된 x를 참조하는 변수는 없게 되어서 GC가 동작하게 됩니다. 
                // 하지만 'a' property는 변수 z가 참조하고 있어서 GC가 동작하지 않습니다.

z = null;       // 'a' 를 참조하는 변수는 없게 되어서 GC가 동작하게 됩니다.
```

### Q4-1. GC가 완전하게 동작한다고 보장할 수 있을까요?
A. 보장할 수 없습니다.

Circular reference의 경우를 예로 들겠습니다.
```js
function f(){
    var x = {};
    var y = {};
    x.a = y;    // x는 y를 참조
    y.a = x;    // y는 x를 참조

    return 'azerty';
}

f();
```
위의 예제에서 변수 'x'와 'y'는 서로를 각각 참조하고 있습니다. 함수 'f()'가 실행되고 끝난 이후에 함수 'f' 의 scope에 있는 변수가 반환되어야 하나 Circular reference로 인해서 GC가 동작하지않아 memory leak이 발생합니다.

### Q4-1-1. 그러면 Circular reference를 어떻게 해결할 수 있나요?
Mark-and-sweep 알고리즘이 제안되었으며 2012년 이후에 모든 현대 브라우저의 garbage-collector에 이 알고리즘이 포함되어있습니다.

알고리즘은 '더 이상 필요하지 않는 객체' 대신에 '접근하지 못하는 객체'로 garbage 탐색을 하게 됩니다. '접근하지 못하는 객체'는 root (브라우저의 경우 window 또는 global)에서 참조되지 않는 객체를 뜻하며 위와 같은 circular reference 문제를 해결할 수 있게 되었습니다.

------
정리글: https://velog.io/@whow1101/Deep-Dive4%EC%9E%A5-%EB%B3%80%EC%88%98
