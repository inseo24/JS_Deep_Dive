## #1 변수와 상수

```jsx
var i = 1;
i = 2; // 재할당 가능

const j = {};
j = 3; // error, 상수이므로 재할당 불가

j.a = 20; // 프로퍼티 할당, 재할당은 가능 { a : 20 };
```

## #2 원시값 저장 방식, 불변성

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/90769cf5-c5c6-403c-a168-9c7c2b844019/Untitled.png)

1. 변수 선언 시, 메모리의 한 공간에 식별자가 저장되고, 값은 undefined가 들어있다.

   0xc000000A2 → 식별자 : score, 값 : 0x000000F2 (undefined)

2. 값이 할당될 때, 먼저 80이 메모리의 한 공간에 저장되고, score의 값이 그 주소로 바뀐다.

   (원시값 저장을 위해 먼저 확보해야 하는 메모리 공간의 크기를 결정함)

   0xc000000A2 → 식별자 : score, 값 : 0x000001332 (80)

3. 값이 90으로 재할당 될 경우, 90이 메모리의 한 공간에 저장되고, score의 값이 그 주소로 바뀐다.

   0xc000000A2 → 식별자 : score, 값 : 0x00000F913

⇒ **불변성**은 **값** 자체를 바꾸지 못함을 의미한다. 80이 메모리에 생성되면 그 값을 바꿀 수 없고, 변수에 새로운 값을 할당하려고 하면 다른 메모리에 그 값을 새로 생성한다.

## #3 자바스크립트의 문자열

대부분의 언어에서 문자열을 참조형으로 쓰는 것과 달리 자바스크립트에서는 원시형으로 지정되어 있다. 원시 타입으로 변경이 불가능하다.

```jsx
var str2 = "Hello";

str2; // 'Hello'
str2[2]; // 'l' (유사배열객체, Symbol.iterator로 이터러블함)
str2[2] = "a"; //'a'
str2; //'Hello'

str2 = "world"; // world (주소값의 변경)
```

유사배열객체로 length를 사용할 수 있고, 배열처럼 값에 접근할 수 있다.

문자열 리터럴이 String의 인스터스인 것은 아니다.

문자열에서 slice() 같은 메서드를 쓴다고 하면 내부에선 아래와 같은 작업이 이뤄진다.

```jsx
str2.slice(2, 3);
// 내부 동작 :
// const tempStr2 = new String(str2) -> 원시값을 감싸는 래퍼 객체로 자동 변환
// tempStr2.slice(2,3)
// 값 반환 후 tempStr2는 날림
```

## #4 값에 의한 전달, 참조에 의한 전달

말은 값이 복사된다고 하나 사실상 메모리 주소값이 변경된다.

```jsx
var score = 80;

var copy = score;

console.log(score === copy); // true, 80 80

score = 100;

console.log(scroe === copy); // false, 100 80
// 두 변수의 값은 각자 다른 메모리 공간에 저장된 별개의 값
// score에 100을 할당하면 100을 갖는 메모리 주소가 할당될 뿐,
// copy 변수의 값에는 영향을 주지 않음
```

원시형이든 참조형이든 식별자는 값이 아닌 메모리 주소를 기억하고 있고 결국 이 메모리 주소를 복사해서 전달한다.

즉, 자바스크립트에는 참조에 의한 전달은 존재하지 않고 **값에 의한 전달만이 존재**한다.

## #5 객체

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d017f1ab-51bb-4c28-80d3-f45936bbb39b/Untitled.png)

```jsx
var person = {
  name: "Lee",
};
```

1. person 객체를 생성 시, person 식별자가 중간에 한 단계를 거쳐서(객체가 저장된 공간) 프로퍼티를 참조한다.

   0x00000a → 식별자 : person, 값 : 0x00000F2

2. 0x00000F2 → 0x00001332 ~ 0x0000?? (객체가 저장된 공간)

   객체로 어느 정도 메모리를 미리 확보한다.

3. 0x00001332: { name → 0x00003333 }

   0x00003333: ‘Lee’ (값은 다른 곳에 저장됨)

객체와 원시값의 차이는 1단계를 거치느냐 안 거치느냐이다.

원시값은 바로 참조할 수 있고 객체는 객체의 프로퍼티를 담는 메모리 공간을 저장하고 있는 주소를 거쳐서 참조할 수 있다.

## #6 얕은 복사, 깊은 복사

얕은 복사는 1단계만 복사함을 의미한다.

재귀적으로 참조 가능한 모든 것들을 복사해서(객체에 중첩된 객체까지) 원시값까지 복사하는 것이 깊은 복사다.

```jsx
var a = { a: [1, 2, 3] };
var b = a; // 얕은 복사

a === b; // true

a.a[0] = 4;
b.a[0]; // 4 (양쪽 모두 영향)

var b = { a: [...a.a] }; // 깊은 복사
a.a[0] = 5;
b.a[0]; // 4 (다른 객체로 영향 x)
```

번외)

자바스크립트 메모리

ECMAScript 사양에는 변수를 통해 메모리를 어떻게 관리해야 하는지 명확하게 정의되어 있지 않다.

힙이나 스택 등은 v8 엔진 등 브라우저의 자바스크립트 엔진에 관한 내용으로 각 브라우저 환경에 따라 달라질 수 있다.
